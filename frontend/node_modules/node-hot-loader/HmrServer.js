"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _fs = _interopRequireDefault(require("fs"));

var _path = _interopRequireDefault(require("path"));

var _requireFromString = _interopRequireDefault(require("require-from-string"));

var _child_process = require("child_process");

var _LogColors = _interopRequireDefault(require("./LogColors"));

var _Logger = _interopRequireDefault(require("./Logger"));

var _LogLevel = require("./LogLevel");

var _messageActionType = _interopRequireDefault(require("./messageActionType"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class HmrServer {
  static defaultReporter({
    context,
    stateValid,
    stats,
    compilerOptions
  }) {
    // for check log level for webpack compiler only
    const compilerLogLevel = (0, _LogLevel.parseLogLevel)(compilerOptions.stats);

    if (!stateValid) {
      if (compilerLogLevel >= _LogLevel.LogLevel.MINIMAL) {
        context.webpackLogger.info('Compiling...');
      }

      return;
    }

    if (compilerLogLevel > _LogLevel.LogLevel.NONE) {
      const statsInfo = stats.toString(compilerOptions.stats);

      if (statsInfo) {
        // To avoid log empty statsInfo, e.g. when options.stats is 'errors-only'.
        context.webpackLogger.info(statsInfo);
      }
    }

    if (compilerLogLevel >= _LogLevel.LogLevel.ERRORS) {
      if (stats.hasErrors()) {
        context.webpackLogger.error('Failed to compile.');
      } else if (stats.hasWarnings()) {
        context.webpackLogger.warn('Compiled with warnings.');
      }
    }

    if (compilerLogLevel >= _LogLevel.LogLevel.MINIMAL) {
      context.webpackLogger.info('Compiled successfully.');
    }
  }

  /**
   * @param {{
   *  compiler: import('webpack').Compiler;
   *  fork?: boolean | string[];
   *  args?: string[];
   *  inMemory?: boolean;
   *  logLevel?: string;
   * }} options
   */
  constructor(_options) {
    _defineProperty(this, "context", {
      /** When started compiled script contains process object in which script running. */
      serverProcess: null,

      /** Valid or invalid state. */
      stateValid: false,

      /** Last compiler stats. */

      /** @type import('webpack').Stats */
      webpackStats: undefined,

      /** Compiler watching by compiler.watch(...). */
      watching: undefined,

      /**
       * Do not use memory-fs because we can't fork bundle from in-memory file.
       */
      fs: _fs.default,
      reporter: HmrServer.defaultReporter,
      logger: new _Logger.default(_LogColors.default.cyan('[HMR]')),
      webpackLogger: new _Logger.default(_LogColors.default.magenta('Webpack')),
      compiler: undefined,
      fork: false,
      args: undefined,
      inMemory: false,
      logLevel: undefined
    });

    _defineProperty(this, "sendMessage", action => {
      if (!this.context.serverProcess) {
        return;
      }

      const logLevel = this.context.logLevel != null ? (0, _LogLevel.parseLogLevel)(this.context.logLevel) : (0, _LogLevel.parseLogLevel)(this.context.compiler.options.stats);

      if (this.context.fork) {
        this.context.serverProcess.send({
          action,
          stats: this.context.webpackStats.toJson(),
          logLevel
        });
      } else {
        this.context.serverProcess.emit('message', {
          action,
          stats: this.context.webpackStats.toJson(),
          logLevel
        });
      }
    });

    _defineProperty(this, "launchAssets", stats => {
      const getLauncherFileName = () => {
        const assets = Object.values(stats.toJson().entrypoints).reduce((acc, group) => {
          return acc.concat(...group.assets.filter(asset => !asset.endsWith('.map')).map(asset => _path.default.resolve(stats.compilation.compiler.outputPath, asset)));
        }, []);

        if (assets.length === 1) {
          // Only one valid assets, so just return it path
          return assets[0];
        } // Create temp launcher file which aggregates all assets.


        const launcherString = assets.map(asset => `require('${asset.replace(/\\/g, '/')}');`).join('\n');

        const launcherFileName = _path.default.resolve(stats.compilation.compiler.outputPath, `launcher.${stats.hash}.js`);

        this.context.fs.writeFileSync(launcherFileName, launcherString); // Delete created files on exit main process.

        const deleteLauncher = () => this.context.fs.unlinkSync(launcherFileName);

        process.on('exit', deleteLauncher);
        process.on('SIGINT', deleteLauncher);
        return launcherFileName;
      }; // Execute built scripts


      if (this.context.fork) {
        /** @type import('child_process').ForkOptions */
        const options = {
          cwd: process.cwd(),
          env: process.env,
          execArgv: this.context.fork === true ? undefined : this.context.fork
        };

        if (process.getuid) {
          options.uid = process.getuid();
          options.gid = process.getgid();
        }

        this.context.serverProcess = (0, _child_process.fork)(getLauncherFileName(), this.context.args || process.argv, options); // Listen for serverProcess events.

        this.context.serverProcess.on('exit', code => {
          // Exit node process when exit serverProcess.
          process.exit(code);
        });
        this.context.logger.info('Launch assets in forked process.');
      } else {
        // Require in current process to lauch script.
        Promise.resolve().then(() => {
          if (this.context.inMemory) {
            (0, _requireFromString.default)(this.context.fs.readFileSync(getLauncherFileName()).toString());
          } else {
            require(`${getLauncherFileName()}`);
          }
        }).then(() => {
          this.context.serverProcess = process;
        }).catch(err => {
          this.context.logger.error(err);
          process.exit();
        });
      }
    });

    _defineProperty(this, "compilerStart", () => {
      try {
        this.sendMessage(_messageActionType.default.CompilerStart);

        if (this.context.watching && this.context.stateValid) {
          this.context.reporter({
            stateValid: false,
            context: this.context,
            compilerOptions: this.context.compiler.options
          });
        } // We are now in invalid state


        this.context.stateValid = false;
      } catch (ex) {
        this.context.logger.error(ex);
      }
    });

    _defineProperty(this, "compilerDone", stats => new Promise(resolve => {
      // We are now on valid state
      this.context.stateValid = true;
      this.context.webpackStats = stats; // Do the stuff in nextTick, because bundle may be invalidated
      // if a change happened while compiling

      process.nextTick(() => {
        // check if still in valid state
        if (!this.context.stateValid) return; // print webpack output

        if (this.context.watching) {
          this.context.reporter({
            stateValid: true,
            stats,
            context: this.context,
            compilerOptions: this.context.compiler.options
          });
        }

        if (this.context.serverProcess) {
          // Already has launched process
          this.sendMessage(_messageActionType.default.CompilerDone);
        } else {
          // Start compiled files in child process (fork) or in current process.
          this.launchAssets(stats);
        }

        resolve();
      });
    }).catch(ex => {
      this.context.logger.error(ex);
    }));

    _defineProperty(this, "compilerWatch", err => {
      if (err) {
        this.context.logger.error(err.stack || err);
        if (err.details) this.context.logger.error(err.details);
      }
    });

    _defineProperty(this, "startWatch", () => {
      const {
        compiler
      } = this.context; // start watching

      this.context.watching = compiler.watch(compiler.options.watchOptions, this.compilerWatch);
      this.context.logger.info('Waiting webpack...');
    });

    _defineProperty(this, "run", (watch = true) => {
      const {
        compiler
      } = this.context;

      if (compiler.hooks) {
        // webpack >= 4
        compiler.hooks.invalid.tap('node-hot-loader', this.compilerStart);
        compiler.hooks.done.tapPromise('node-hot-loader', this.compilerDone);
      } else {
        // webpack < 4
        compiler.plugin('invalid', this.compilerStart);
        compiler.plugin('done', this.compilerDone);
      }

      if (watch) {
        this.startWatch();
      }

      return this;
    });

    this.context = { ...this.context,
      ..._options
    };
    const {
      compiler: _compiler,
      inMemory
    } = this.context;

    if (inMemory) {
      const getName = () => 'memory-fs';

      const MemoryFileSystem = require(getName());

      this.context.fs = new MemoryFileSystem();
      _compiler.outputFileSystem = this.context.fs;
    } // if (typeof compiler.outputPath === 'string' && !path.isAbsolute(compiler.outputPath)) {
    //   throw new Error('`output.path` needs to be an absolute path or `/`.');
    // }

  }

}

exports.default = HmrServer;